{"version":3,"file":"smartsettings.es.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/index.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import style from './index.css'\n\n/**\n * @class SmartSettings\n * @classdesc SmartSettings module, returns new SmartSettings instance\n * @param {string} name - name of the SmartSettings panel\n * @param {number} left - position of the SmartSettings panel on X axis\n * @param {number} top - position of the SmartSettings panel on Y axis\n * @example\n * const mySettings = new SmartSettings('My Settings', 10, 10)\n*/\nclass SmartSettings {\n    constructor(name = 'SmartSettings', left = 0, top = 0) {\n        this.name = name\n        this.initialLeft = left\n        this.initialTop = top\n\n        /**\n         * @property {boolean} _hidden\n         * @private\n         */\n        this._hidden = false\n\n        /**\n         * @property {boolean} _open\n         * @private\n         */\n        this._open = true\n\n        /**\n         * @property {Node} _panel\n         * @private\n         */\n        this._panel = null\n\n        /**\n         * @property {object} _controls\n         * @private\n         */\n        this._controls = {}\n\n        /**\n         * @property {string} _localString\n         * It lets creating unique identifier for the panels\n         * @private\n         */\n        this._localString = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)\n\n        /**\n         * @property {?function} _globalWatcher\n         * @private\n         */\n        this._globalWatcher = null\n\n        this._createUniqueId()\n        this._create(this.name, this.initialTop, this.initialLeft)\n\n        /**\n         * @property {?Node} _panelBody - body div\n         * @private\n         */\n        this._body = this._panel ? this._panel.childNodes[1] : null\n    }\n\n    /* Utility methods */\n\n    /**\n     * Inits function that creates unique element identifier\n     * @returns {string}\n     * @private\n     */\n    _createUniqueId() {\n        let counter = 0\n        this.uniqueID = () => `${this._localString}-${counter++}`\n    }\n     \n    /**\n     * Creates any DOM element\n     * @param {string} type - type of the DOM element\n     * @param {Object} attributes - object with all attributes for the DOM element\n     * @returns {Node}\n     * @private \n     */\n    _createElement(type, attributes) {\n        let element = document.createElement(type)\n        if (attributes) {\n            for (let key in attributes) {\n                if (key === 'class') {\n                    element.setAttribute('class', attributes[key])\n                } else {\n                    element[key] = attributes[key]\n                }\n            }\n        }\n        return element\n    }\n\n    /**\n     * Creates label element\n     * @param {string} name - name in the label\n     * @returns {Node}\n     * @private\n     */\n    _createLabel(name) {\n        return this._createElement('label', {\n            class: 'sms-label',\n            innerText: name,\n            value: name\n        })\n    }\n    /**\n     * Calls the global watcher\n     * @param {EventListenerObject} event - an event\n     * @returns {void}\n     * @private\n     */\n    _callGlobalWatcher(e) {\n        if (this._globalWatcher) {\n            this._globalWatcher(e)\n        }\n    }\n\n    /**\n     * Assigns config entry to the specific control creation method\n     * @param {object} entry - entry of the config object|array\n     * @private\n     */\n    _assignEntryToMethod(_entry) {\n        let _isCallback = _entry.callback ? _entry.callback : null\n        switch (_entry.type) {\n        case 'button':\n            this.button(_entry.name, _isCallback)\n            break\n        case 'range':\n            this.range(_entry.name, _entry.items, _isCallback)\n            break\n        case 'select':\n            this.select(_entry.name, _entry.items, _isCallback)\n            break\n        case 'text':\n            this.text(_entry.name, _entry.value, _isCallback)\n            break\n        case 'textarea':\n            this.textarea(_entry.name, _entry.value, _isCallback)\n            break\n        case 'checkbox':\n            this.checkbox(_entry.name, _entry.value, _isCallback)\n            break\n        case 'number':\n            this.number(_entry.name, _entry.items, _isCallback)\n            break\n        case 'color':\n            this.color(_entry.name, _entry.value, _isCallback)\n            break\n        case 'file':\n            this.file(_entry.name, _isCallback)\n        }\n    }\n\n    /**\n     * Dispatches an event after setting new items or new value to the control\n     * @param {Node} element - DOM element dispatcher\n     * @param {string} type - type of the control\n     * @returns {void}\n     * @private\n     */\n    _dispatchEvent(element, type) {\n        let _eventType\n        if (type === 'button') {\n            _eventType = 'click'\n        }\n        if (\n            type === 'text' || \n            type === 'textarea' || \n            type === 'range' ||\n            type === 'color' ||\n            type === 'number'\n        ) {\n            _eventType = 'input'\n        }\n        if (\n            type === 'checkbox' ||\n            type === 'select' ||\n            type === 'file'\n        ) {\n            _eventType = 'change'\n        }\n        element.dispatchEvent(new Event(_eventType))\n    }\n\n    /* Helper methods */\n\n    /**\n     * Creates settings panel, invoked on class construction\n     * @returns {void}\n     * @private\n     */\n    _create() {\n        let self = this\n        let panelAttributes = {\n            class: 'sms-panel',\n            id: this.uniqueID(),\n            style: `top: ${this.initialTop}px; left: ${this.initialLeft}px; z-index: 2`\n        }\n        let panel = this._createElement('div', panelAttributes)\n        let header = this._createElement('div', { class: 'sms-panel-header' })\n        let body = this._createElement('div', { class: 'sms-panel-body' })\n        let paragraph = this._createElement('p', { class: 'sms-panel-header-name' })\n        let toggleSpan = this._createElement('span', { \n            class: 'sms-panel-header-span', \n            id: `${this._localString}-toggle-span`\n        })\n        toggleSpan.innerText = '–'\n        header.addEventListener('click', e => this.toggle())\n        paragraph.innerText = this.name\n        header.appendChild(paragraph)\n        header.appendChild(toggleSpan)\n        panel.appendChild(header)\n        panel.appendChild(body)\n        this._panel = panel\n        document.body.appendChild(this._panel)\n    }\n\n    /**\n     * Updates header span content depending on the _open property\n     * @returns {void}\n     * @private\n     */\n    _updateHeaderSpan() {\n        let span = document.getElementById(`${this._localString}-toggle-span`)\n        span.innerText = this._open === true ? '–' : '+'\n    }\n\n    /**\n     * Creates basic properties for the new control\n     * @returns {object}\n     * @private\n     */\n    _createControlBasics() {\n        let id = this.uniqueID()\n        let basics = {\n            id: id,\n            disabled: false,\n            hidden: false,\n            value: null,\n            name: null,\n            type: null,\n            callback: null,\n            element: function() {\n                return document.getElementById(this.id)\n            },\n            enable: function() {\n                this.element().removeAttribute('disabled')\n                this.disabled = false\n            },\n            disable: function() {\n                this.element().setAttribute('disabled', true)\n                this.disabled = true\n            },\n            show: function() {\n                if (this.element().parentNode.classList[1] === 'hide') {\n                    this.element().parentNode.classList.remove('hide')\n                    this.hidden = false\n                }\n            },\n            hide: function() {\n                if (this.element().parentNode.classList[1] !== 'hide') {\n                    this.element().parentNode.classList.add('hide')\n                    this.hidden = true\n                }\n            }\n        }\n        return basics\n    }\n\n    /**\n     * Returns select option\n     * @param {(string|number)} item - option value\n     * @param {boolean} [selected] - is option selected\n     * @returns {Node}\n     * @private\n     */\n    _createSelectOption(item, selected) {\n        let option = this._createElement('option', {\n            class: 'sms-select-option',\n            value: item,\n            innerText: item,\n            selected: selected ? selected : false\n        })\n        return option\n    }\n\n    /* Basic methods */\n\n    /**\n     * Removes settings panel from the DOM and removes all sections and controls\n     * @returns {void}\n     * @example\n     * mySettings.destroy()\n     */\n    destroy() {\n        if (this._panel && this._panel.parentElement) {\n            this._panel.parentElement.removeChild(this._panel)\n        }\n        this._panel = null\n        this._controls = {}\n    }\n\n    /**\n     * Shows settings panel or specific control (if the name is provided)\n     * @param {string} [name] - name of control to be shown\n     * @returns {void}\n     * @example\n     * mySettings.show()\n     */\n    show(name) {\n        if (name) {\n            this._controls[name].show()\n        } else {\n            this._panel.classList.remove('hide')\n            this._hidden = false\n        }\n    }\n\n    /**\n     * Hides settings panel or specific control (if the name is provided)\n     * @param {string} [name] - name of control to be hidden\n     * @returns {void}\n     * @example\n     * mySettings.hide()\n     */\n    hide(name) {\n        if (name) {\n            this._controls[name].hide()\n        } else {\n            this._panel.classList.add('hide')\n            this._hidden = true\n        }\n    }\n\n    /**\n     * Enables specific control\n     * @param {string} name\n     * @returns {void}\n     * @example\n     * mySettings.enable('Checkbox control')\n     */\n    enable(name) {\n        if (name && this._controls[name]) {\n            return this._controls[name].enable()\n        }\n    }\n\n    /**\n     * Disables specific control\n     * @param {string} name\n     * @returns {void}\n     * @example\n     * mySettings.enable('Checkbox control')\n     */\n    disable(name) {\n        if (name && this._controls[name]) {\n            return this._controls[name].disable()\n        }\n    }\n\n    /**\n     * Open settings panel\n     * @example\n     * mySettings.open()\n     */\n    open() {\n        if (this._body.classList[1] === 'hide') {\n            this._body.classList.remove('hide')\n        } \n        this._open = true\n        this._updateHeaderSpan()\n    }\n\n    /**\n     * Close settings panel\n     * @example\n     * mySettings.close()\n     * \n     */\n    close() {\n        this._body.classList.add('hide')\n        this._open = false\n        this._updateHeaderSpan()\n    }\n\n    /**\n     * Open or close settings panel depending on `_open` property\n     * @returns {void}\n     * @example\n     * mySettings.toggle()\n     */\n    toggle() {\n        this._body.classList[1] === 'hide' ?\n            this._body.classList.remove('hide') :\n            this._body.classList.add('hide')\n        this._open = !this._open\n        this._updateHeaderSpan()\n    }\n\n    /**\n     * Returns panel position [left, top]\n     * @return {array<string>}\n     * @example\n     * let position = mySettings.getPosition() // [0, 0]\n     */\n    getPosition() {\n        return [\n            this._panel.style.left,\n            this._panel.style.top\n        ]\n    }\n\n    /**\n     * Sets panel position\n     * @param {number} left - new position on the X axis\n     * @param {number} top - new position on the Y axis\n     * @example\n     * mySettings.setPosition(400, 400)\n     */\n    setPosition(left, top) {\n        this._panel.style.left = `${left}px`\n        this._panel.style.top = `${top}px`\n    }\n\n    /**\n     * Removes specific control\n     * @param {string} name - name of the control to be deleted\n     * @returns {void}\n     * @example\n     * mySettings.remove('Control name')\n     */\n    remove(name) {\n        if (name) {\n            let elem = this._controls[name].element()\n            elem.parentElement.remove()\n            elem.remove()\n            delete this._controls[name]\n        }\n    }\n\n    /**\n     * Removes all controls from the panel\n     * @param {boolean} [removeName] - set to true if you want to clean the panel's name. Default set to false\n     * @returns {void}\n     * @example\n     * mySettings.removeAll()\n     */\n    removeAll(removeName = false) {\n        for (let key in this._controls) {\n            delete this._controls[key]\n        }\n    }\n\n    /**\n     * Get value of specific control\n     * @param {string} name - name of the control\n     * @returns {(number|string|boolean)}\n     * @example\n     * let value = mySettings.getValue('Control name')\n     */\n    getValue(name) {\n        if (name && this._controls[name] && this._controls[name].getValue) {\n            return this._controls[name].getValue()\n        }\n    }\n\n    /**\n     * Sets new active value of the specific control. (Changing button control value does not change its' id property)\n     * @param {string} name - name of the control\n     * @param {(number|string|boolean)} name - new value\n     * @param {boolean} [syntheticEvent] - specify, if method should dispatch syntethic event after items update. Default value is false\n     * @returns {void}\n     * @example\n     * mySettings.setValue('Control name', 'value')\n     */\n    setValue(name, value, syntheticEvent = false) {\n        let _control = this._controls[name]\n        if (name && _control && _control.setValue) {\n            return _control.setValue(value, syntheticEvent)\n        }\n    }\n\n    /**\n     * Get all active values\n     * @returns {object} - an object with values from all currently set controls\n     * @example\n     * let values = mySettings.getActiveValues()\n     */\n    getActiveValues() {\n        let values = {}\n        for (let i in this._controls) {\n            if (this._controls[i].getValue) {\n                values[i] = this._controls[i].getValue()\n            }\n        }\n        return values\n    }\n\n    /**\n     * Get selected index of the select control\n     * @param {string} name - name of the control\n     * @returns {number}\n     * @example\n     * let currentIndex = mySettings.getIndex('Select control')\n     */\n    getIndex(name) {\n        if (name && this._controls[name].getIndex) {\n            return this._controls[name].getIndex()\n        }\n    }\n\n    /**\n     * Set selected index of the select control\n     * @param {string} name - name of the control\n     * @param {number} index - new active index\n     * @param {boolean} [syntheticEvent] - specify, if method should dispatch syntethic event after items update. Default value is false\n     * @returns {void}\n     * @example\n     * mySettings.setIndex('Select', 4)\n     */\n    setIndex(name, index, syntheticEvent = false) {\n        if (name && this._controls[name].setIndex) {\n            return this._controls[name].setIndex(index, syntheticEvent)\n        }\n    }\n\n    /**\n     * Get select/range items\n     * @param {string} name - name of the control\n     * @returns {array}\n     * @example\n     * let selectValues = mySettings.\n     */\n    getItems(name) {\n        let typeCondition = (\n            this._controls[name].type === 'range' || \n            this._controls[name].type === 'select' || \n            this._controls[name].type === 'progressbar'\n        )\n        if (this._controls[name] && typeCondition) {\n            return this._controls[name].getItems()\n        } else {\n            throw new Error('Chosen control is not a range or select type')\n        }\n    }\n\n    /**\n     * Set (update) select/range items\n     * @param {string} name - name of the control\n     * @param {array} items - array of new items\n     * @param {boolean} [syntheticEvent] - specify, if method should dispatch syntethic event after items update. Default value is false\n     * @returns {void}\n     * @example\n     * mySettings.setItems('Select', [1, 2, 3, 4])\n     */\n    setItems(name, items, syntheticEvent = false) {\n        let typeCondition = (\n            this._controls[name].type === 'range' ||\n            this._controls[name].type === 'select' ||\n            this._controls[name].type === 'progressbar'\n        )\n        if (this._controls[name] && typeCondition) {\n            return this._controls[name].setItems(items, syntheticEvent)\n        } else {\n            throw new Error('Chosen control is not a range or select type')\n        }\n    }\n\n    /**\n     * Creates button control\n     * @param {string} name - name of the control \n     * @param {function} callback - function executed on each change\n     * @returns {object} button control object\n     * @example\n     * let button = mySettings.button('Button Name', () => console.log('This is the button'))\n     */\n    button(name, callback) {\n        let self = this\n        let base = this._createControlBasics()\n        let wrapper = this._createElement('div', {\n            class: 'sms-control'\n        })\n        let button = this._createElement('button', {\n            class: 'sms-button',\n            id: base.id,\n            innerText: name,\n            value: name\n        })\n        base.type = 'button'\n        base.name = name\n        base.callback = callback || null\n        button.addEventListener('click', e => {\n            if (callback) {\n                callback(e)\n            }\n            if (self._globalWatcher !== null) {\n                self._callGlobalWatcher(e)\n            }\n        })\n        wrapper.appendChild(button)\n        this._body.appendChild(wrapper)\n        this._controls[name] = base\n        return this._controls[name]\n    }\n\n    /**\n     * Creates text input control\n     * @param {string} name - name of the control\n     * @param {string} value - value of the control\n     * @param {function} [callback] - function executed on each change\n     * @returns {object}\n     * @example\n     * let textInput = mySettings.text('Text input', 'Hello world')\n     */\n    text(name, value, callback) {\n        let self = this\n        let base = this._createControlBasics()\n        let wrapper = this._createElement('div', { class: 'sms-control' })\n        let label = this._createLabel(name)\n        let input = this._createElement('input', {\n            class: 'sms-text',\n            id: base.id,\n            type: 'text',\n            innerText: value,\n            placeholder: value,\n            value: value\n        })\n        base.name = name\n        base.value = value\n        base.type = 'text'\n        base.callback = callback || null\n        wrapper.appendChild(label)\n        wrapper.appendChild(input)\n        input.addEventListener('input', e => {\n            base.value = e.target.value\n            if (callback) {\n                callback(e)\n            }\n            if (self._globalWatcher !== null) {\n                self._callGlobalWatcher(e)\n            }\n        })\n        this._body.appendChild(wrapper)\n        base.getValue = function() {\n            return this.element().value\n        }\n        base.setValue = function (value, syntheticEvent) {\n            base.value = value\n            base.element().innerText = value\n            base.element().value = value\n            if (syntheticEvent === true)\n                self._dispatchEvent(base.element(), base.type)\n        }\n        this._controls[name] = base\n        return this._controls[name]\n    }\n\n    /**\n     * Creates textarea control\n     * @param {string} name - name of the control\n     * @param {string} value - value of the control\n     * @param {function} [callback] - function executed on each change\n     * @returns {object}\n     * @example\n     * let textarea = mySettings.textarea('Text input', 'Hello world')\n     */\n    textarea(name, value, callback) {\n        let self = this\n        let base = this._createControlBasics()\n        let wrapper = this._createElement('div', { class: 'sms-control' })\n        let label = this._createLabel(name)\n        let textarea = this._createElement('textarea', {\n            class: 'sms-textarea',\n            id: base.id,\n            innerText: value,\n            value: value,\n            placeholder: value\n        })\n        base.name = name\n        base.value = value\n        base.type = 'textarea'\n        base.callback = callback || null\n        wrapper.appendChild(label)\n        wrapper.appendChild(textarea)\n        textarea.addEventListener('input', e => {\n            base.value = e.target.value\n            if (callback) {\n                callback(e)\n            }\n            if (self._globalWatcher !== null) {\n                self._callGlobalWatcher(e)\n            }\n        })\n        base.getValue = function () {\n            return this.element().value\n        }\n        base.setValue = function (value, syntheticEvent) {\n            base.value = value\n            base.element().innerText = value\n            base.element().value = value\n            if (syntheticEvent === true)\n                self._dispatchEvent(base.element(), base.type)\n        }\n        this._body.appendChild(wrapper)\n        this._controls[name] = base\n        return this._controls[name]\n    }\n\n    /**\n     * Creates range control\n     * @param {string} name - name of the control\n     * @param {array} items - array with min, max, default and step values\n     * @param {function} [callback] - function executed on each change\n     * @returns {object}\n     * @example\n     * let range = mySettings.range('Range', [1, 100, 40, 1], e => console.log(e.target.value))\n     */\n    range(name, items, callback) {\n        let self = this\n        let base = this._createControlBasics()\n        let wrapper = this._createElement('div', { class: 'sms-control' })\n        let label = this._createLabel(name)\n        let span = this._createElement('span', { class: 'sms-label-span' })\n        let input = this._createElement('input', {\n            class: 'sms-range',\n            id: base.id,\n            type: 'range',\n            min: items[0],\n            max: items[1],\n            value: items[2],\n            step: items[3]\n        })\n        base.type = 'range'\n        base.name = name\n        base.value = items[2]\n        base.callback = callback || null\n        input.addEventListener('input', e => {\n            base.value = parseFloat(e.target.value)\n            span.innerText = base.value\n            if (callback) {\n                callback(e)\n            }\n            if (self._globalWatcher !== null) {\n                self._callGlobalWatcher(e)\n            }\n        })\n        span.innerText = base.value\n        label.appendChild(span)\n        wrapper.appendChild(label)\n        wrapper.appendChild(input)\n        this._body.appendChild(wrapper)\n        base.getValue = function() {\n            return parseFloat(base.element().value)\n        }\n        base.setValue = function(v, syntheticEvent) {\n            base.value = v\n            base.element().value = v\n            span.innerText = v\n            if (syntheticEvent === true)\n                self._dispatchEvent(base.element(), base.type)\n        }\n        base.getItems = function() {\n            let e = base.element()\n            return [\n                parseFloat(e.min),\n                parseFloat(e.max),\n                parseFloat(e.value),\n                parseFloat(e.step),\n            ]\n        }\n        base.setItems = function(items, syntheticEvent) {\n            let e = base.element()\n            e.min = items[0]\n            e.max = items[1]\n            e.value = items[2]\n            e.step = items[3]\n            base.value = parseFloat(e.value)\n            span.innerText = parseFloat(e.value)\n            if (syntheticEvent === true)\n                self._dispatchEvent(base.element(), base.type)\n        }\n        this._controls[name] = base\n        return this._controls[name]\n    }\n\n    /**\n     * Creates checkbox control\n     * @param {string} name - name of the control\n     * @param {boolean} value - value of the control\n     * @param {function} [callback] - function executed on each change\n     * @returns {object}\n     * @example\n     * let checkbox = mySettings.checkbox('Check this out!', true, e => {\n     *      console.log(e.target.value)\n     * })\n     */\n    checkbox(name, value, callback) {\n        let self = this\n        let base = this._createControlBasics()\n        let wrapper = this._createElement('div', { class: 'sms-control' })\n        let label = this._createLabel(name)\n        let checkbox = this._createElement('input', {\n            class: 'sms-checkbox',\n            id: base.id,\n            type: 'checkbox'\n        })\n        base.name = name\n        base.type = 'checkbox'\n        base.value = value\n        base.callback = callback || null\n        if (value === true) {\n            checkbox.setAttribute('checked', true)\n        }\n        checkbox.addEventListener('change', e => {\n            base.value = e.target.checked\n            if (callback) {\n                callback(e)\n            }\n            if (self._globalWatcher !== null) {\n                self._callGlobalWatcher(e)\n            }\n        })\n        wrapper.appendChild(label)\n        wrapper.appendChild(checkbox)\n        base.getValue = function() {\n            return base.element().checked\n        }\n        base.setValue = function(v, syntheticEvent) {\n            base.element().checked = v\n            base.value = v\n            if (syntheticEvent === true)\n                self._dispatchEvent(base.element(), base.type)\n        }\n        this._body.appendChild(wrapper)\n        this._controls[name] = base\n        return this._controls[name]\n    }\n\n    /**\n     * Creates color control\n     * @param {string} name - name of the control\n     * @param {string} value -hexadecimal string value of initial color\n     * @param {function} [callback] - function executed afer each change\n     * @returns {object}\n     * @example\n     * let color = mySettings.color('Color control', '#fcfcfc', e => someCallbackFunction())\n     */\n    color(name, value, callback) {\n        let self = this\n        let base = this._createControlBasics()\n        let wrapper = this._createElement('div', { class: 'sms-control' })\n        let label = this._createLabel(name)\n        let span = this._createElement('span', { class: 'sms-label-span' })\n        let input = this._createElement('input', {\n            class: 'sms-color',\n            id: base.id,\n            type: 'color'\n        })\n        base.name = name\n        base.type = 'color'\n        base.value = value\n        base.callback = callback || null\n        input.setAttribute('value', value)\n        input.addEventListener('input', e => {\n            base.value = e.target.value\n            span.innerText = e.target.value\n            if (callback) {\n                callback(e)\n            }\n            if (self._globalWatcher !== null) {\n                self._callGlobalWatcher(e)\n            }\n        })\n        span.innerText = value\n        label.appendChild(span)\n        wrapper.appendChild(label)\n        wrapper.appendChild(input)\n        base.getValue = function() {\n            return base.element().value\n        }\n        base.setValue = function(v, syntheticEvent) {\n            base.element().value = v\n            base.value = v\n            span.innerText = v\n            if (syntheticEvent === true)\n                self._dispatchEvent(base.element(), base.type)\n        }\n        this._body.appendChild(wrapper)\n        this._controls[name] = base\n        return this._controls[name]\n    }\n\n    /**\n     * Creates select control\n     * @param {string} name - name of the control\n     * @param {array} items - array with option values\n     * @param {function} [callback] - function executed on each change\n     * @returns {object}\n     * @example\n     * let select = mySettings.select('Select', ['Option 1', 'Option 2', 'Option 3'])\n     */\n    select(name, items, callback) {\n        let self = this\n        let base = this._createControlBasics()\n        let wrapper = this._createElement('div', { class: 'sms-control' })\n        let label = this._createLabel(name)\n        let select = this._createElement('select', {\n            class: 'sms-select',\n            id: base.id,\n            name: name,\n            value: items[0]\n        })\n        wrapper.appendChild(label)\n        items.map(item => {\n            let option = self._createSelectOption(item)\n            select.options.add(option)\n        })\n        select.addEventListener('change', e => {\n            base.value = e.target.value\n            if (callback) {\n                callback(e)\n            }\n            if (self._globalWatcher !== null) {\n                self._callGlobalWatcher(e)\n            }\n        })\n        wrapper.appendChild(select)\n        base.value = items[0]\n        base.name = name\n        base.type = 'select'\n        base.callback = callback || null\n        base.getValue = function() {\n            let _select = base.element()\n            return _select.options[_select.selectedIndex].value\n        }\n        base.setValue = function(v, syntheticEvent) {\n            base.value = v\n            let _select = base.element()\n            select.options[select.selectedIndex] = self._createSelectOption(v)\n            _select.value = v\n            if (syntheticEvent === true)\n                self._dispatchEvent(base.element(), base.type)\n        }\n        base.getItems = function() {\n            return Array\n                .from(base.element().options)\n                .map(option => option.value)\n        }\n        base.setItems = function(items, syntheticEvent) {\n            const _current = {\n                selected: base.element().selectedIndex,\n                length: base.getItems().length\n            }\n            const _new = {\n                selected: -1,\n                length: items.length\n            }\n\n            if (_new.length > _current.length) {\n                if (_current.selected === -1 || _current.selected === '') {\n                    _new.selected = 0\n                }\n                if (_current.selected > -1) {\n                    _new.selected = _new.length - 1\n                }\n            }\n            if (_new.length < _current.length) {\n                if (_current.selected > - 1 && _current.selected < _new.length) {\n                    _new.selected = _current.selected\n                }\n                if (_current.selected > _new.length - 1) {\n                    _new.selected = _new.length - 1\n                }\n            }\n\n            for (let i = 0; i < base.element().options.length; i++) {\n                base.element().options[i].remove()\n            }\n            items.forEach(item => {\n                let _index = items.indexOf(item)\n                base.element().options[_index] = self._createSelectOption(\n                    item,\n                    _index = _new.selected ? true : false\n                )\n            })\n            base.value = items[_new.selected]\n            if (syntheticEvent === true)\n                self._dispatchEvent(base.element(), base.type)\n        }\n        base.getIndex = function() {\n            return parseInt(base.element().selectedIndex)\n        }\n        base.setIndex = function(value, syntheticEvent) {\n            base.element().selectedIndex = value\n            base.value = base.element().options[value].value\n            if (syntheticEvent === true) {\n                self.dispatchEvent(base.element(), base.type)\n            }\n        }\n        this._body.appendChild(wrapper)\n        this._controls[name] = base\n        return this._controls[name]\n    }\n\n    /**\n     * Creates number control\n     * @param {string} name - name of the control\n     * @param {array} items - array with initial and step value\n     * @param {function} [callback] - function executed on each change\n     * @returns {object}\n     * @example\n     * let number = mySettings.number('Number', [10, 1], e => {})\n     */\n    number(name, items, callback) {\n        let self = this\n        let base = this._createControlBasics()\n        let wrapper = this._createElement('div', { class: 'sms-control' })\n        let label = this._createLabel(name)\n        let input = this._createElement('input', {\n            class: 'sms-number',\n            id: base.id,\n            type: 'number',\n            value: items[0],\n            step: items[1]\n        })\n        input.addEventListener('input', e => {\n            base.value = parseFloat(e.target.value)\n            if (callback) {\n                callback(parseFloat(e))\n            }\n            if (self._globalWatcher !== null) {\n                self._callGlobalWatcher(e)\n            }\n        })\n        base.type = 'number'\n        base.name = name\n        base.value = items[0]\n        base.callback = callback || null\n        base.getValue = function() {\n            return parseFloat(base.element().value)\n        }\n        base.setValue = function(v, syntheticEvent) {\n            base.element().value = v\n            base.value = v\n            if (syntheticEvent === true)\n                self._dispatchEvent(base.element(), base.type)\n        }\n        wrapper.appendChild(label)\n        wrapper.appendChild(input)\n        this._body.appendChild(wrapper)\n        this._controls[name] = base\n        return this._controls[name] = base\n    }\n\n    /**\n     * Creates file input control\n     * @param {string} name - name of the control\n     * @param {function} [callback] - function executed on each change\n     * @returns {object}\n     * @example\n     * let fileControl = mySettings.file('File control', someCallbackFunction)\n     */\n    file(name, callback) {\n        let self = this\n        let base = this._createControlBasics()\n        let wrapper = this._createElement('div', { class: 'sms-control' })\n        let label = this._createLabel(name)\n        let upload = this._createElement('input', {\n            class: 'sms-file',\n            id: base.id,\n            type: 'file'\n        })\n        base.name = name\n        base.type = 'file'\n        base.callback = callback || null\n        upload.addEventListener('change', e => {\n            base.value = e.target.value\n            if (callback) {\n                callback(e)\n            }\n            if (self._globalWatcher) {\n                self._callGlobalWatcher(e)\n            }\n        })\n        wrapper.appendChild(label)\n        wrapper.appendChild(upload)\n        base.getValue = function() {\n            return base.element().files[0]\n        }\n        base.setValue = function(v, syntheticEvent) {\n            base.value = v\n            base.element().files[0] = v\n            if (syntheticEvent === true)\n                self._dispatchEvent(base.element(), base.type)\n        }\n        this._body.appendChild(wrapper)\n        this._controls[name] = base\n        return this._controls[name] = base\n    }\n\n    /**\n     * Watch panel for changes and fire callback on each change\n     * @param {function} callback - function executed on each change in the panel\n     * @returns {void}\n     * @example\n     * mySettings.watch(callback)\n     */\n    watch(callback) {\n        this._globalWatcher = callback\n    }\n\n    /**\n     * Load controls from the configuration object.\n     * @param {(object|string|array)} config - configuration object or JSON string or configuration array of objects\n     * @returns {void}\n     * @example\n     * const mySettings = new SmartSettings('Name', 10, 10)\n     * mySettings.loadConfig({\n     *      control1: {\n     *          type: 'color',\n     *          name: 'Color',\n     *          value: '#fd3ef4',\n     *          callback: someCallbackFunction\n     *      },\n     *      // etc.\n     * })\n     * \n     * // or\n     * mySettings.loadConfig('{\n     *      \"control1\": {\n     *          \"type\": \"color\",\n     *          \"name\": \"Color\",\n     *          \"value\": \"#fd3ef4\",\n     *          \"callback\": \"someCallbackFunction\"\n     *      },\n     *      // etc.\n     * }')\n     * \n     * // or\n     * mySettings.loadConfig([{\n     *      {\n     *          type: 'color',\n     *          name: 'Color',\n     *          value: '#fd3ef4',\n     *          callback: someCallbackFunction\n     *      },\n     *      // etc.\n     * ])\n     */\n    loadConfig(config) {\n        if (!config) {\n            throw new Error('There is no config provided')\n        }\n        if (typeof config === 'string' || !Array.isArray(config)) {\n            if (typeof config === 'string') {\n                config = JSON.parse(config)\n            }\n            for (let key in config) {\n                let _entry = config[key]\n                this._assignEntryToMethod(_entry)\n            }\n        }\n        if (Array.isArray(config) === true) {\n            config.forEach(entry => this._assignEntryToMethod(entry))\n        }\n    }\n\n    /**\n     * Returns current configuration\n     * @param {string} [output] - unless there is an output parameter specified, this method returns an object. But you can set an output to be an 'array' or JSON 'string'\n     * @returns {(object|array|string)}\n     * @example\n     * let currentConfig = mySettings.getConfig('array')\n     * // returns array of control objects\n     */\n    getConfig(output = 'object') {\n        let _valueOrItems\n        let _obj = {}\n        let decide = ctrl => {\n            if (\n                ctrl.type === 'select' ||\n                ctrl.type === 'range' ||\n                ctrl.type === 'number'\n            ) {\n                return {\n                    items: ctrl.getItems()\n                }\n            } else {\n                return {\n                    value: ctrl.getValue()\n                }\n            }\n        }\n        for (let key in this._controls) {\n            let _control = this._controls[key]\n            if (_control.type === 'button') {\n                _obj[key] = {\n                    type: _control.type,\n                    name: _control.name\n                }\n                if (_control.callback !== null) {\n                    _obj[key].callback = _control.callback\n                }\n            } else {\n                let itemsOrValue = decide(_control)\n                _obj[key] = Object.assign({\n                    type: _control.type,\n                    name: _control.name\n                }, itemsOrValue)\n                if (_control.callback !== null) {\n                    _obj[key].callback = _control.callback\n                }\n            }\n        }\n        if (!output || output === 'object') {\n            return _obj\n        }\n        if (output === 'array') {\n            return Object.values(_obj)\n        }\n        if (output === 'string') {\n            return JSON.stringify(_obj, null, 4)\n        }\n    }\n}\n\nexport default SmartSettings"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","name","left","top","initialLeft","initialTop","_hidden","_open","_panel","_controls","_localString","Math","random","toString","substring","_globalWatcher","_createUniqueId","_create","this","_body","childNodes","counter","uniqueID","_this","attributes","element","key","setAttribute","_createElement","e","_entry","_isCallback","callback","button","range","items","select","text","value","textarea","checkbox","number","color","file","_eventType","dispatchEvent","Event","panelAttributes","panel","header","class","body","paragraph","toggleSpan","innerText","addEventListener","_this2","toggle","getElementById","id","removeAttribute","disabled","parentNode","classList","remove","hidden","add","item","selected","parentElement","removeChild","show","hide","enable","disable","_updateHeaderSpan","elem","getValue","syntheticEvent","_control","setValue","values","i","getIndex","index","setIndex","typeCondition","getItems","Error","setItems","self","base","_createControlBasics","wrapper","_callGlobalWatcher","label","_createLabel","input","target","_dispatchEvent","span","parseFloat","v","min","max","step","checked","map","option","_createSelectOption","options","_select","selectedIndex","Array","from","_current","length","_new","forEach","_index","indexOf","parseInt","upload","files","config","isArray","JSON","parse","_assignEntryToMethod","_this3","entry","output","_obj","itemsOrValue","ctrl","Object","assign","stringify"],"mappings":"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"}